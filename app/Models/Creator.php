<?php

namespace App\Models;

use App\Exceptions\ErrorException;
use App\Models\Traits\ThirdPartyParser;
use Cviebrock\EloquentSluggable\Sluggable;
use DB;
use Exception;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\HigherOrderBuilderProxy;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use League\CommonMark\Environment;
use Performance\Performance;
use Psr\SimpleCache\InvalidArgumentException;
use Throwable;

/**
 * Class Creator
 * @package App\Models
 * @author  Cookie
 */
class Creator extends Model
{
    use
        HasFactory,
        ThirdPartyParser,
        Sluggable;

    protected $fillable = ['name', 'description', 'country_id', 'likes_count'];

    protected static function boot()
    {
        self::creating(function (self $creator) {
            $creator->created_by_id = auth()->guard('api')->id();
        });

        parent::boot(); // TODO: Change the autogenerated stub
    }

    /**
     * @return Creator|Model
     */
    static public function createNew()
    {
        return self::create([
            'name'        => '',
            'description' => '',
        ]);
    }

    /**
     * @param $countryString
     * @return $this
     */
    public function setCountry($countryString): Creator
    {
        $country = Country::where('alpha_2_code', trim(strtoupper($countryString)))
            ->orWhere('alpha_3_code', trim(strtoupper($countryString)))
            ->orWhere('en_short_name', $countryString)
            ->orWhere('nationality', $countryString)
            ->first();

        $this->country()->associate($country);

        return $this;
    }

    /**
     * @param array $info
     * @param string $source
     * @return $this
     * @throws InvalidArgumentException
     * @throws Throwable
     */
    public function saveInfo(array $info, string $source): self
    {
        foreach ($info as $field => $value) {
            CreatorInfo::updateOrCreate([
                // conditions
                'creator_id' => $this->id,
                'source_id'  => Source::getId($source),
                'field'      => $field,
            ],
                [
                    // value update
                    'value' => is_array($value) ? json_encode($value) : $value,
                ]);
        }

        return $this;
    }

    /**
     * @param string $fieldName
     * @param Source|int $source
     * @return HigherOrderBuilderProxy|mixed
     */
    public function getInfo(string $fieldName, $source)
    {
        return optional(
            $this
                ->info()
                ->where('field', $fieldName)
                ->where('source_id', Source::id($source))
                ->first()
        )->value;
    }

    /**
     * @param $fieldName
     * @param Source|int $source
     * @throws Exception
     */
    public function deleteInfo($fieldName, $source)
    {
        CreatorInfo::whereField($fieldName)
            ->whereCreatorId($this->id)
            ->whereSourceId(Source::id($source))
            ->delete();
    }

    /**
     * @return HasMany
     */
    public function info()
    {
        return $this->hasMany(CreatorInfo::class, 'creator_id');
    }

    /**
     * @return BelongsToMany
     */
    public function categories()
    {
        return $this->belongsToMany(Category::class);
    }

    /**
     * @return BelongsToMany
     */
    public function sources()
    {
        return $this->belongsToMany(Source::class);
    }

    /**
     * @return HasMany
     */
    public function collabs1()
    {
        return $this->hasMany(Collab::class, 'creator1_id');
    }

    /**
     * @return HasMany
     */
    public function collabs2()
    {
        return $this->hasMany(Collab::class, 'creator2_id');
    }

    /**
     * @return $this
     */
    public function loadCollabs()
    {
        $this->collabs = $this->collabs1()->get()->merge($this->collabs2()->get());

        return $this;
    }

    /**
     * @return BelongsTo
     */
    public function country()
    {
        return $this->belongsTo(Country::class);
    }

    /**
     * @return BelongsTo
     */
    public function image()
    {
        return $this->belongsTo(Image::class);
    }

    /**
     * @param array $info
     * @param Source|int $source
     * @return $this
     */
    public function withInfo(array $info, $source): self
    {
        return $this->saveInfo($info, $source);
    }

    /**
     * @param array $info
     * @param string $source
     * @return $this
     */
    public function updateInfo(array $info, string $source): Creator
    {
        $this->saveInfo($info, $source);

        return $this;
    }

    /**
     * @param $image - array ['url'=> .., 'data'=> ..]
     * @return $this
     */
    public function updateImage($image): Creator
    {
        if ($this->image_id) {
            $this->image->update($image);
        } else {
            $this->image()->associate(
                Image::create($image)
            );
        }

        return $this;
    }

    /**
     * @param Builder $builder
     * @param string $query
     * @param int|null $limit
     * @return Builder
     */
    public function scopeSearch(Builder $builder, string $query, $limit = null): Builder
    {
        return $builder
            ->where('name', 'like', strlen($query) >= 3 ? "%$query%" : "$query%")
            //@todo scopes
            ->with(['info', 'image', 'categories', 'sources'])
            ->limit($limit ?? 10)
            ->orderByDesc('priority');
    }

    /**
     * @return Category
     * @todo finish main category
     */
    public function mainCategory()
    {
        //return
    }

    /**
     * @return $this
     */
    public function recomputePriority(): self
    {
        $priority = 0;

        $this->load('sources');

        foreach ($this->sources as $source) {
            $priority += $this->getInfo($source->priority_field, $source);
        }

        $priority += $this->collabsLikes();

        $this->priority = $priority;
        $this->save();

        return $this;
    }

    /**
     * @return int
     */
    public function collabsLikes(): int
    {
        $id = $this->id;

        $result = DB::select(<<<SQL
            SELECT COUNT(l.id) AS likesCount
            FROM collabs AS c
            JOIN likes AS l ON c.id = l.collab_id
            WHERE c.creator1_id = $id OR c.creator2_id  = $id
            GROUP BY l.id;
SQL
        );

        if (isset($result[0])) {
            return $result[0]->likesCount;
        }

        return 0;
    }

    /**
     * @param $name
     * @return $this
     * @throws InvalidArgumentException
     * @throws Throwable
     */
    public function setSource($name): Creator
    {
        $sourceId = Source::getId($name);
        if (!$this->sources->contains($sourceId)) {
            $this->sources()->attach($sourceId);
        }
        return $this;
    }

    /**
     * @return string[][]
     */
    public function sluggable(): array
    {
        return [
            'slug' => [
                'source' => 'name',
            ]
        ];
    }

    /**
     * @param array $data
     * @return $this
     * @throws InvalidArgumentException
     * @throws Throwable
     */
    public function updateComplex(array $data): self
    {
        $this
            ->updateInfo(@$data['info'], @$data['source'])
            ->setSource(@$data['source'])
            ->updateImage(@$data['image'])
            ->setCountry(@$data['country'])
            ->update(@$data['data']);

        $this
            ->load('image', 'info', 'country', 'categories');

        return $this;
    }

    /**
     * @return MorphMany
     */
    public function comments(): MorphMany
    {
        return $this->morphMany(Comment::class, 'commentable');
    }

    /**
     *
     */
    public function loadSources()
    {
        $this->load('sources');
        foreach ($this->sources as $source) {
            $source->attributes['profile_url'] = $this->getInfo('url', $source);
        }
    }

    /**
     * @param null $userId
     * @return $this
     * @throws ErrorException
     */
    public function addLike($userId = null): self
    {
        $data = [
            'user_id'    => $userId ?? auth()->id(),
            'creator_id' => $this->id,
        ];

        if (CreatorLike::where($data)->exists()) {
            // User has liked this comment already
            throw new ErrorException(20103);
        }

        // fire "like"
        CreatorLike::create($data);

        return $this
            ->recomputeLikes()
            ->loadCount('userLikes');
    }

    /**
     * @param null $userId
     * @return $this
     * @throws ErrorException
     */
    public function deleteLike($userId = null): self
    {
        $data = [
            'user_id'    => $userId ?? auth()->id(),
            'creator_id' => $this->id,
        ];

        if (!$like = CreatorLike::where($data)->first()) {
            // Like does not exist
            throw new ErrorException(20104);
        }

        $like->delete();

        return $this
            ->recomputeLikes()
            ->loadCount('userLikes');
    }

    /**
     * @return HasMany
     */
    public function likes(): HasMany
    {
        return $this->hasMany(CreatorLike::class);
    }

    /**
     * @return HasMany
     */
    public function userLikes(): HasMany
    {
        return $this
            ->hasMany(CreatorLike::class)
            ->where('user_id', auth()->guard('api')->id());
    }

    /**
     * @return $this
     */
    public function recomputeLikes(): self
    {
        $this->update(
            ['likes_count' => $this->likes()->count()],
            ['timestamps' => false],
        );

        return $this;
    }
}
